<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>faux</title>
        <meta name="robots" content="noindex" />

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="faux.html">faux</a></li><li class="chapter-item expanded affix "><a href="motivation.html">Motivation</a></li><li class="chapter-item expanded "><a href="guide/getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Stub Behavior (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Argument Matching (Coming Soon)</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Equality (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Any (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Pattern (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Custom Closure (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Advanced (Coming Soon)</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Pointer Receivers (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Interactions With Other Macros (Coming Soon)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> External Modules (Coming Soon)</div></li><li class="chapter-item expanded "><a href="guide/exporting-mocks.html"><strong aria-hidden="true">7.</strong> Exporting Mocks Across Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Unsafe Uses (Coming Soon)</div></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="blog/introducing-faux.html">introducing faux</a></li><li class="chapter-item expanded affix "><a href="blog/an-inside-look.html">an inside look</a></li><li class="chapter-item expanded affix "><a href="blog/landing-v-0-1.html">landing v0.1</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                        </div>

                        <h1 class="menu-title">faux</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><em>This guide is incomplete and in active development. Visit the <a href="https://docs.rs/faux/">API
docs</a> for an accurate view into faux</em></p>
<h1 id="faux"><a class="header" href="#faux">faux</a></h1>
<p><strong>faux</strong> is a library to create <a href="https://martinfowler.com/articles/mocksArentStubs.html">mocks</a> out of structs.</p>
<p>With faux you can stub the behavior of your structs during tests, thus
allowing you to write readable and maintainable unit tests.</p>
<blockquote>
<p>Mocking is a powerful technique to write repeatable <strong>unit</strong>
tests. Mocks let you focus on a particular system or component by
mocking the dependencies underneath that may be hard or not valuable
to setup in your unit tests. These kind of tests are not meant to
replace higher level tests that would verify the correctness of your
application as a whole.</p>
</blockquote>
<p>This book is split into two sections: a guide for using faux, and an
appendix of blog posts regarding faux.</p>
<h2 id="more-information"><a class="header" href="#more-information">More Information</a></h2>
<p>For a deeper dive into the api of faux, you can read the <a href="https://docs.rs/faux/">API
docs</a>. faux is open source and it is available under an MIT License in
<a href="https://github.com/nrxus/faux/">github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>faux was created with the purpose of simplifying mocking in Rust.</p>
<h2 id="no-undue-abstractions"><a class="header" href="#no-undue-abstractions">No undue abstractions</a></h2>
<p>A typical technique for mocking in Rust is to use generics to provide
a real implementation in production and a fake implementation in
tests. Adding these generics create a layer of abstraction that is not
necessery outside of tests. Abstractions are not free. Abstractions
affect the readability and maintainability of your code so its cost
needs to be outweighed by its benefits. In this case the benefit is
only testability thus making it an undue burden.</p>
<p>It is the author's belief that writing traits solely for testing are
an undue burden and create an unnecessary layer of abstraction.</p>
<p>In comparison, faux works by changing the implementation of a struct
at compile time. These changes should be gated to only apply during
tests, thus having zero effect in your production code. The goal of
faux is to allow you to create mocks out of your existing code without
forcing you write unnecessary abstractions.</p>
<h2 id="mocking-behavior"><a class="header" href="#mocking-behavior">Mocking behavior</a></h2>
<p>faux is designed to mock <em>visibile behavior</em>. In Rust terms, faux is
designed to mock <em>public methods</em>. Private methods are not visible and
thus not mockable using faux. Fields of a struct are not behavior and
thus not mockable using faux.</p>
<blockquote>
<p>Free functions and associated functions are behavior but are not
currently supported by faux. faux's current focus is object mocking,
but functions may come in the future. Submit an issue if you wish to
see function mocking so its relative priority can be known.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p><code>faux</code> makes liberal use of unsafe Rust features, so it is only
recommended for use inside tests. Follow the steps below to configure
<code>faux</code> and the created mocks to only exist during tests.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><code>faux</code> should be added under <code>[dev-dependencies]</code> in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dev-dependencies]
faux = "^0.1"
</code></pre>
<p>This makes sure that <code>faux</code> only gets included when compiling and
running tests, thus making it impossible to leak into production code.</p>
<h2 id="your-first-mock"><a class="header" href="#your-first-mock">Your First Mock</a></h2>
<p><code>faux</code> is able to mock a <code>struct</code> and its public methods. To do this,
<code>faux</code> provides two attributes: <code>#[faux::create]</code> and
<code>#[faux::methods]</code>. <code>#[faux::create]</code> tags the struct we wish to make
mockable. <code>#[faux::methods]</code> tags the <code>impl</code> blocks of that
struct. Both of these attributes must be used.</p>
<pre><pre class="playground"><code class="language-rust">#[cfg_attr(test, faux::create)]
pub struct MyStructToMock { /* fields */ }

#[cfg_attr(test, faux::methods)]
impl MyStructToMock { /* methods to mock */ }
<span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let's say you are writing a restaurant reservation system. One of the
core structs in this system is a <code>RestaurantClient</code> which sends HTTP
requests to get availability times for a restaurant, create a
reservation, cancel, etc.</p>
<pre><pre class="playground"><code class="language-rust">pub struct RestaurantClient {
    /* snip */
}

impl RestaurantClient {
    pub fn new() -&gt; Self {
        /* snip */
<span class="boring">        todo!()
</span>    }

    pub fn availabilities(&amp;self) -&gt; Result&lt;Vec&lt;Availability&gt;, Error&gt; {
        /* GET to some HTTP endpoint */
<span class="boring">        todo!()
</span>    }

    pub fn reserve(&amp;self, availability: Availability) -&gt; Result&lt;Reservation, Error&gt; {
        /* POST to some HTTP endpoint */
<span class="boring">        todo!()
</span>    }

    pub fn cancel(&amp;self, reservation: Reservation) -&gt; Result&lt;(), Error&gt; {
        /* DELETE to some HTTP endpoint */
<span class="boring">        todo!()
</span>    }
}
<span class="boring">
</span><span class="boring">pub struct Reservation { /* snip */ }
</span><span class="boring">pub struct Availability { /* snip */ }
</span><span class="boring">pub struct Error { /* snip */ }
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>This type is not interesting to unit-test in itself as it is very
declarative. Aside from the fact that it doesn't have any real logic
to unit-test, calling these methods will send actual HTTP requests to
create or cancel reservations, which is bound to make your tests slow
and flaky. You will also probably have some really angry restaurants.</p>
<blockquote>
<p>You may want to have some kind of integration or enemy tests that
verifies the overall correctness of your service that will end up
testing this struct, but that goes beyond the scope of this guide.</p>
</blockquote>
<p>However, a more interessting part of your library deals with
<em>choosing</em> from the possible availabilities and reserves a spot at the
restaurant. Let's call it <code>Concierge</code>.</p>
<pre><pre class="playground"><code class="language-rust">use restaurant_client::{RestaurantClient, Reservation};

pub struct Concierge {
    client: RestaurantClient,
}

impl Concierge {
    pub fn new(client: RestaurantClient) -&gt; Self {
        Concierge {
            client,
        }
    }

    pub fn reserve_matching(&amp;self, options: Options) -&gt; Result&lt;Reservation, Error&gt; {
        /* logic to find a matching availability and reserve it */
<span class="boring">        todo!()
</span>    }
}
<span class="boring">
</span><span class="boring">pub struct Options { /* snip */ }
</span><span class="boring">pub enum Error {
</span><span class="boring">    Client(restaurant_client::Error),
</span><span class="boring">}
</span><span class="boring">impl From&lt;restaurant_client::Error&gt; for Error {
</span><span class="boring">    fn from(error: restaurant_client::Error) -&gt; Self {
</span><span class="boring">        Error::Client(error)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">mod restaurant_client {
</span><span class="boring">    pub struct RestaurantClient {}
</span><span class="boring">    impl RestaurantClient {
</span><span class="boring">       pub fn availabilities(&amp;self) -&gt; Result&lt;Vec&lt;Availability&gt;&gt; {
</span><span class="boring">           todo!()
</span><span class="boring">       }
</span><span class="boring">       pub fn reserve(&amp;self, availability: Availability) -&gt; Result&lt;Reservation&gt; {
</span><span class="boring">           todo!()
</span><span class="boring">       }
</span><span class="boring">    }
</span><span class="boring">    pub struct Reservation { /* snip */ }
</span><span class="boring">    pub struct Availability { /* snip */ }
</span><span class="boring">    pub struct Error { /* snip */ }
</span><span class="boring">    pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Unlike <code>ReservationClient</code>, the <code>Concierge</code> does hold a key piece of
domain logic: how to choose between the available times. This logic is
worth unit tests as it is vital to our service and we want to make
sure that it continues working as we refactor or add features to
<code>reserve_matching</code>. However, we do not want to make actual calls to
the <code>ReservationClient</code> as that would mean having to make network
requests. To solve this, we decide to mock <code>ReservationClient</code> for our
tests. <code>faux</code> makes it easy to make this struct mockable using the
<code>faux::create</code> and <code>faux::methods</code> attributes.</p>
<pre><pre class="playground"><code class="language-rust">// gate the attribute to only tests
// `faux` is (and should be!) only available when running tests
#[cfg_attr(test, faux::create)]
pub struct RestaurantClient {
    /* snip */
}

// gate the attribute to only tests
#[cfg_attr(test, faux::methods)]
impl RestaurantClient {
    pub fn new() -&gt; Self {
        /* snip */
<span class="boring">        todo!()
</span>    }

    pub fn availabilities(&amp;self) -&gt; Result&lt;Vec&lt;Availability&gt;, Error&gt; {
        /* snip */
<span class="boring">        todo!()
</span>    }

    pub fn reserve(&amp;self, availability: Availability) -&gt; Result&lt;Reservation, Error&gt; {
        /* snip */
<span class="boring">        todo!()
</span>    }

    pub fn cancel(&amp;self,  reservation: Reservation) -&gt; Result&lt;(), Error&gt; {
        /* snip */
<span class="boring">        todo!()
</span>    }
}
<span class="boring">
</span><span class="boring">pub struct Reservation { /* snip */ }
</span><span class="boring">pub struct Availability { /* snip */ }
</span><span class="boring">pub struct Error { /* snip */ }
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Using these two attributes allows/signals <code>faux</code> to hook into the
struct and its methods at compile time to create mockable versions of
them that can be used in your tests. Note that there are zero changes
to the implementation or signature of <code>ReservationClient</code>, the only
change is tagging it with the <code>faux</code> attributes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use restaurant_client::{RestaurantClient, Reservation};
</span><span class="boring">pub struct Concierge {
</span><span class="boring">    client: RestaurantClient,
</span><span class="boring">}
</span><span class="boring">impl Concierge {
</span><span class="boring">    pub fn new(client: RestaurantClient) -&gt; Self {
</span><span class="boring">        Concierge {
</span><span class="boring">            client,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub fn reserve_matching(&amp;self, options: Options) -&gt; Result&lt;Reservation, Error&gt; {
</span><span class="boring">        let _ = options;
</span><span class="boring">        let chosen_availability = self.client
</span><span class="boring">            .availabilities()?
</span><span class="boring">            .pop()
</span><span class="boring">            .ok_or(Error::NoReservations)?;
</span><span class="boring">        let reservation = self.client.reserve(chosen_availability)?;
</span><span class="boring">        Ok(reservation)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Options { /* snip */ }
</span><span class="boring">#[derive(Clone, Debug)]
</span><span class="boring">pub enum Error {
</span><span class="boring">    Client(restaurant_client::Error),
</span><span class="boring">    NoReservations,
</span><span class="boring">}
</span><span class="boring">impl From&lt;restaurant_client::Error&gt; for Error {
</span><span class="boring">    fn from(error: restaurant_client::Error) -&gt; Self {
</span><span class="boring">        Error::Client(error)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">mod restaurant_client {
</span><span class="boring">    #[faux::create]
</span><span class="boring">    pub struct RestaurantClient {}
</span><span class="boring">    #[faux::methods]
</span><span class="boring">    impl RestaurantClient {
</span><span class="boring">       pub fn availabilities(&amp;self) -&gt; Result&lt;Vec&lt;Availability&gt;&gt; {
</span><span class="boring">           todo!()
</span><span class="boring">       }
</span><span class="boring">       pub fn reserve(&amp;self, availability: Availability) -&gt; Result&lt;Reservation&gt; {
</span><span class="boring">           todo!()
</span><span class="boring">       }
</span><span class="boring">    }
</span><span class="boring">    #[derive(Clone, Debug, PartialEq)]
</span><span class="boring">    pub struct Reservation { /* snip */ }
</span><span class="boring">    #[derive(Clone, Debug, PartialEq)]
</span><span class="boring">    pub struct Availability { /* snip */ }
</span><span class="boring">    #[derive(Clone, Debug)]
</span><span class="boring">    pub struct Error { /* snip */ }
</span><span class="boring">    pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
</span><span class="boring">}
</span><span class="boring">extern crate faux;
</span><span class="boring">use faux::when;
</span><span class="boring">use restaurant_client::Availability;
</span><span class="boring">fn main() {
</span><span class="boring">    // first test
</span><span class="boring">    let mut client = RestaurantClient::faux();
</span><span class="boring">    let availability = Availability { /*snip */ };
</span><span class="boring">    let expected_reservation = Reservation { /* snip */ };
</span><span class="boring">
</span><span class="boring">    when!(client.availabilities())
</span><span class="boring">        .then_return(Ok(vec![availability.clone()]));
</span><span class="boring">
</span><span class="boring">    when!(client.reserve(availability))
</span><span class="boring">        .then_return(Ok(expected_reservation.clone()));
</span><span class="boring">
</span><span class="boring">    let subject = Concierge::new(client);
</span><span class="boring">    let options = Options { /* snip */ };
</span><span class="boring">    let reservation = subject
</span><span class="boring">        .reserve_matching(options).expect("expected successful reservation");
</span><span class="boring">
</span><span class="boring">    assert_eq!(reservation, expected_reservation);
</span><span class="boring">
</span><span class="boring">    // second test
</span><span class="boring">    let mut client = RestaurantClient::faux();
</span><span class="boring">    when!(client.availabilities()).then_return(Ok(vec![]));
</span><span class="boring">
</span><span class="boring">    let subject = Concierge::new(client);
</span><span class="boring">    let options = Options { /* snip */ };
</span><span class="boring">    let error = subject
</span><span class="boring">        .reserve_matching(options)
</span><span class="boring">        .expect_err("expected error reservation");
</span><span class="boring">
</span><span class="boring">    assert!(matches!(error, Error::NoReservations));
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    use faux::when;

    #[test]
    fn selects_the_only_one() {
        // A `faux()` function to every mockable struct
        // to instantiate a mock instance
        let mut client = RestaurantClient::faux();
        let availability = Availability { /*snip */ };
        let expected_reservation = Reservation { /* snip */ };

        // when!(...) lets you stub the return method of the mock struct
        when!(client.availabilities())
            .then_return(Ok(vec![availability.clone()]));

        // when!(...) lets you specify expected arguments
        // so only invocations that match that argument return the stubbed data
        when!(client.reserve(availability))
            .then_return(Ok(expected_reservation.clone()));

        let subject = Concierge::new(client);
        let options = Options { /* snip */ };
        let reservation = subject
            .reserve_matching(options)
            .expect("expected successful reservation");

        assert_eq!(reservation, expected_reservation);
    }

    #[test]
    fn fails_when_empty() {
        let mut client = RestaurantClient::faux();
        when!(client.availabilities()).then_return(Ok(vec![]));

        let subject = Concierge::new(client);
        let options = Options { /* snip */ };
        let error = subject
            .reserve_matching(options)
            .expect_err("expected error reservation");

        assert!(matches!(error, Error::NoReservations));
    }
}</code></pre></pre>
<p>You have now successfully added tests for <code>Concierge</code> that use a mock
instance of the <code>RestaurantClient</code>. Note that neither the
implementation of <code>Concierge</code> nor <code>RestaurantClient</code> had to change in
order to be mockable. You can write production ready code without
incurring any abstraction penalty for using mocks in testing.</p>
<h2 id="recap"><a class="header" href="#recap">Recap</a></h2>
<ul>
<li>
<p>Use <code>faux</code> as a <code>dev-dependency</code> to avoid it leaking into production
code.</p>
</li>
<li>
<p><code>faux::create</code> and <code>faux::methods</code> are attributes used to tag
structs and methods for mocking. These tags should be gated to tests
only using <code>#[cfg_attr(test, ...)]</code></p>
</li>
<li>
<p><code>faux::when!</code> is used to stub the returned data of a method in a
mocked struct.</p>
</li>
<li>
<p><code>faux::when!</code> lets you specify argument matchers so stubs are used
only for certain invocations. The default is an equality matcher,
but there are also other matchers if you want to match any argument,
match a pattern, or match based on the result of a given predicate.
See the [when docs] for more information.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exporting-mocks-across-crates"><a class="header" href="#exporting-mocks-across-crates">Exporting Mocks Across Crates</a></h1>
<p>As an application or library grows, it is common to split it into
multiple crates.  This separation of responsibilities help to simplify
code, but there is a snag: mocks.</p>
<p>If any code is tagged wth the <code>#[cfg(test)]</code> attribute, Rust does not
allow it to be exported outside its crate. This is great! We
definitely do not want to be building or running someone else's tests
when testing our crate. This means, however, that the mockable version
of our structs are also not exported, as <code>faux</code> was gated to only work
during tests.</p>
<p>This chapter explores a solution for exporting mocks across
crates. Mocks can then be used within multiple crates of the same
project, or even exposed to users of your library so they can mock
your structs when testing their own library or application.</p>
<blockquote>
<p>The solution explored in this chapter applies not only to <code>faux</code> but
to any "test" code you want to export across crates.</p>
</blockquote>
<p>To better explain, let's start with an example. Let's say we are
building a graphics rendering library, <code>testable-renderer</code>. As
expected, <code>faux</code> is declared in <code>dev-dependencies</code></p>
<pre><code class="language-toml">[package]
name = "testable-renderer"

[dev-dependencies]
faux = "^0.1"
</code></pre>
<p>And the code uses mocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate faux;
</span><span class="boring">#[faux::create]
</span>#[cfg_attr(test, faux::create)]
pub struct Renderer {
    /* snip */
<span class="boring">    _inner: u8,
</span>}

<span class="boring">#[faux::methods]
</span>#[cfg_attr(test, faux::methods)]
impl Renderer {
    pub fn new() -&gt; Renderer {
        /* snip */
<span class="boring">        unimplemented!()
</span>    }

    pub fn render(&amp;mut self, texture: &amp;Texture) -&gt; Result&lt;(), RenderError&gt; {
        /* snip */
<span class="boring">        unimplemented!()
</span>    }
}

pub struct Texture;

impl Texture {
    pub fn render(&amp;self, renderer: &amp;mut Renderer) -&gt; Result&lt;(), RenderError&gt; {
        renderer.render(self)
    }
}

#[derive(Debug)]
pub struct RenderError;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn renders_textures() {
        let mut renderer = Renderer::faux();
        faux::when!(renderer.render).then(|_| Ok(()));

        let subject = Texture {};
        subject.render(&amp;mut renderer).expect("failed to render the texture")
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut renderer = Renderer::faux();
</span><span class="boring">    faux::when!(renderer.render).then(|_| Ok(()));
</span><span class="boring">    let subject = Texture {};
</span><span class="boring">    subject.render(&amp;mut renderer).expect("failed to render the texture")
</span><span class="boring">}</span></code></pre></pre>
<h2 id="faux-as-a-feature"><a class="header" href="#faux-as-a-feature"><code>faux</code> as a feature</a></h2>
<p>For the mocks to be exported, they need to be built even outside of
tests. However, we do not want to pollute the production builds of our
library nor anyone using our library with <code>faux</code> and mocks, so we make
our dependency on <code>faux</code> optional:</p>
<pre><code class="language-toml">[dependencies]
# set up an optional feature outside of dev-dependencies so that users
# of this library can use our mocks in their own tests
faux = { version = "^0.1", optional = true }

[dev-dependencies]
# our tests still depend on faux; so add it again but do not make it
# optional
faux = "^0.1"
</code></pre>
<p>Note that we still include <code>faux</code> in <code>dev-dependencies</code>. Our tests are
always dependent on <code>faux</code>, since they use mocks, so the dependency is
not optional.</p>
<p>With this new config, Cargo exposes a new feature flag called
<code>faux</code>. <code>faux</code> will only be built for tests and when the flag is
enabled, which will be explained later.</p>
<h2 id="gating-mocks-to-feature-flag"><a class="header" href="#gating-mocks-to-feature-flag">Gating mocks to feature flag</a></h2>
<p>Now that we have a <code>faux</code> feature flag, we want our mocks to be
created when that flag is turned on. This is accomplished using the
<code>any</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">// mocks are available for both test and the faux feature flag
#[cfg_attr(any(test, feature = "faux"), faux::create)]
pub struct Renderer {
    /* snip */
<span class="boring">    _inner: u8,
</span>}

// mocks are available for both test and the faux feature flag
#[cfg_attr(any(test, feature = "faux"), faux::methods)]
impl Renderer {
    pub fn new() -&gt; Renderer {
        /* snip */
<span class="boring">        unimplemented!()
</span>    }

    pub fn render(&amp;mut self, texture: &amp;Texture) -&gt; Result&lt;(), RenderError&gt; {
        /* snip */
<span class="boring">        unimplemented!()
</span>    }
}

<span class="boring">pub struct RenderError;
</span><span class="boring">pub struct Texture;
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>The key thing to remember here is replacing:</p>
<pre><pre class="playground"><code class="language-rust">#[cfg_attr(test, ...)]
<span class="boring">fn main()</span></code></pre></pre>
<p>with</p>
<pre><pre class="playground"><code class="language-rust">#[cfg_attr(any(test, feature = "faux"), ...)]
<span class="boring">fn main()</span></code></pre></pre>
<p>This tells Rust to use the <code>faux</code> attributes (<code>create</code> and <code>methods</code>)
for either <code>test</code> or the <code>faux</code> feature flag. You can learn more about
the <code>any</code> attribute in the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">Rust Reference</a>.</p>
<p>These are all the changes necessary in our rendering library. The
tests remain the same, and there are no implementation changes.</p>
<h2 id="using-the-faux-feature"><a class="header" href="#using-the-faux-feature">Using the <code>faux</code> feature</a></h2>
<p>Let's now move on to a dependent of our rendering library. The
dependency is marked in its <code>Cargo.toml</code> as:</p>
<pre><code class="language-toml">[dependencies]
testable-renderer = * // some version
</code></pre>
<p>We would now like to use <code>testable-renderer</code> to render multiple
textures for some <code>World</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod testable_renderer {
</span><span class="boring">    extern crate faux;
</span><span class="boring">    #[faux::create]
</span><span class="boring">    pub struct Renderer {
</span><span class="boring">        _inner: u8,
</span><span class="boring">    }
</span><span class="boring">    #[faux::methods]
</span><span class="boring">    impl Renderer {
</span><span class="boring">        pub fn new() -&gt; Renderer {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">        pub fn render(&amp;mut self, texture: &amp;Texture) -&gt; Result&lt;(), RenderError&gt; {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    pub struct Texture;
</span><span class="boring">    impl Texture {
</span><span class="boring">        pub fn render(&amp;self, renderer: &amp;mut Renderer) -&gt; Result&lt;(), RenderError&gt; {
</span><span class="boring">            renderer.render(self)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    #[derive(Debug)]
</span><span class="boring">    pub struct RenderError;
</span><span class="boring">}
</span>use testable_renderer::{RenderError, Renderer, Texture};

struct World {
    player: Texture,
    enemy: Texture,
}

impl World {
    pub fn new() -&gt; Self {
        World {
            player: Texture {},
            enemy: Texture {},
        }
    }

    pub fn render(&amp;self, renderer: &amp;mut Renderer) -&gt; Result&lt;(), RenderError&gt; {
        self.player.render(renderer)?;
        self.enemy.render(renderer)?;

        Ok(())
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>We would like to write tests for our <code>World::render</code> method, but since
rendering is an expensive opration, this is hard to do without
mocks. Thankfully, <code>testable-renderer</code> is set up to expose its mocks,
so we activate them by configuring the feature flag in our
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
# important so features turned on by dev-dependencies don't infect the
# binary when doing a normal build. This lets us have different feature
# flags in dev-dependencies vs normal dependencies.
resolver = "2"

[dependencies]
# our normal dependency does not activate `faux`, thus keeping it out of
# our released binary
testable-renderer = * # some version

[dev-dependencies]
# for tests, we activate the `faux` feature in our dependency so that
# we can use the exposed mocks
testable-renderer = { version = "*", features = ["faux"] }

# still depend on `faux` so we can use setup the mocks
faux = "^0.1"
</code></pre>
<p>The important takeaways are:</p>
<ul>
<li>
<p><code>resolver = "2"</code>. This is needed so <code>faux</code> stays out of our normal
builds. See the <a href="https://doc.rust-lang.org/nightly/cargo/reference/features.html#feature-resolver-version-2">Cargo Reference</a>.</p>
</li>
<li>
<p>Turn on the feature flag under <code>[dev-dependencies]</code>. We only want to
have access to the mocks in <code>testable-renderer</code> when building tests.</p>
</li>
</ul>
<p>We can now write tests as per usual:</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn renders_the_world() {
        // the test target enables the faux feature on `testable-renderer`
        // thus allowing us to use the mocks of the *external* crate
        let mut renderer = Renderer::faux();
        faux::when!(renderer.render).then(|_| Ok(()));

        let world = World::new();
        world.render(&amp;mut renderer).expect("failed to render the world")
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="recap-1"><a class="header" href="#recap-1">Recap</a></h2>
<p>The library that wants to export its mocks needs to:</p>
<ul>
<li>
<p>Add <code>faux</code> as an optional dependency in <code>Cargo.toml</code>.</p>
</li>
<li>
<p>Create the mocks not only during tests, but also when the <code>faux</code>
feature flag is turned on.</p>
</li>
</ul>
<p>The library or application that wants to use the exported mocks needs
to:</p>
<ul>
<li>
<p>Change the feature resolver to "2" in its <code>Cargo.toml</code>. Be aware
that if you are using a workspace, this needs to be changed in the
workspace's <code>Cargo.toml</code>.</p>
</li>
<li>
<p>Add the dependency with the exported mocks under <code>dev-dependencies</code>
with the <code>faux</code> flag enabled in <code>Cargo.toml</code>.</p>
</li>
</ul>
<p>To see this in action, take a look at the example in the <a href="https://github.com/nrxus/faux/tree/master/examples">faux
repository</a>. <code>testable-renderer</code> is the library with the exported
mocks and <code>world-renderer</code> is the application that uses these mocks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--introducing-faux--"><a class="header" href="#--introducing-faux--">🎉 🎉 Introducing faux 🎉 🎉</a></h1>
<h2 id="what-is-faux"><a class="header" href="#what-is-faux">What is faux?</a></h2>
<p><a href="https://github.com/nrxus/faux"><code>faux</code></a> is a traitless Rust mocking framework for creating mock
objects out of user-defined structs.</p>
<h2 id="why-mock"><a class="header" href="#why-mock">Why mock?</a></h2>
<p>Mock objects are test versions of objects that contain fake
implementations of their behavior. For example, if your code accesses
your file system, makes network requests, or performs other expensive
actions, it is often useful to mock that behavior. Mocking can help
make your tests into true unit tests that run quickly and produce the
same result every time without relying on external dependencies. For a
deeper dive into mocks, read this <a href="https://martinfowler.com/articles/mocksArentStubs.html">post</a>.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate faux;
</span><span class="boring">
</span>#[cfg_attr(test, faux::create)]
<span class="boring">#[faux::create]
</span>pub struct NetworkClient {
    /* data here */
}

#[cfg_attr(test, faux::methods)]
<span class="boring">#[faux::methods]
</span>impl NetworkClient {
    pub fn fetch_id_matching(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}

struct Service {
    client: NetworkClient,
}

impl Service {
    fn do_stuff(&amp;self) -&gt; i32 {
        self.client.fetch_id_matching(3)
    }
}

#[cfg(test)]
#[test]
fn service_does_the_right_thing() {
    // creates a mocked NetworkClient
    let mut client = NetworkClient::faux();

    faux::when!(client.fetch_id_matching).then(|i| {
        // we want to test do_stuff(), which should always call
        // fetch_id_matching with the input 3.
        assert_eq!(i, 3, "expected service to send '3'");
        // mock fetch_id_matching to always return 10
        10
    });

    // create your service using the mocked client
    // the service is the subject under test
    let subject = Service { client };
    let id = subject.do_stuff();
    assert_eq!(id, 10);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   // creates a mocked NetworkClient
</span><span class="boring">   let mut client = NetworkClient::faux();
</span><span class="boring">
</span><span class="boring">   // mock fetch_id_matching
</span><span class="boring">   faux::when!(client.fetch_id_matching).then(|i| {
</span><span class="boring">        assert_eq!(i, 3, "expected service to send '3'");
</span><span class="boring">        10
</span><span class="boring">   });
</span><span class="boring">
</span><span class="boring">   // create your service using the mocked client
</span><span class="boring">   // the service is the subject under test
</span><span class="boring">   let subject = Service { client };
</span><span class="boring">   let id = subject.do_stuff();
</span><span class="boring">   assert_eq!(id, 10);
</span><span class="boring">}</span></code></pre></pre>
<p>By adding <code>faux</code> attributes, we have succesfully mocked
<code>NetworkClient::fetch_id_matching</code> to instead call a closure specified
in the test code and always return 10. Unlike the real method, the
mock does not make a network request. Thus, our test remains
dependable, focused, and free from external dependencies.</p>
<p><code>faux</code> provides users with two attributes: <code>#[faux::create]</code> and
<code>#[faux::methods]</code>. <code>#[faux::create]</code> is required on any struct that
needs to be mocked and <code>#[faux::methods]</code> is required on its <code>impl</code>
block. <code>faux</code> also provides a <code>when!</code> macro to mock methods that
were made mockable by <code>#[faux::methods]</code>. See the <a href="https://docs.rs/faux/">docs</a> for more information.</p>
<h2 id="how-is-faux-different-than-existing-mocking-framework"><a class="header" href="#how-is-faux-different-than-existing-mocking-framework">How is faux different than ${existing mocking framework}?</a></h2>
<p><strong>DISCLAIMER: this section is based on the author's knowledge of Rust
mocking frameworks as of January 2020. Apologies in advance for any
frameworks that were overlooked.</strong></p>
<p>Currently in Rust, mocking depends heavily on traits.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NetworkClient {
    /* data here */
}

impl NetworkClient {
    fn fetch_id_matching(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}

struct Service {
    client: NetworkClient,
}

impl Service {
    fn do_stuff(&amp;self) -&gt; i32 {
        self.client.fetch_id_matching(3)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, we want to test <code>Service</code> to make sure it
does the right thing. However, we want to avoid the expensive work
done in <code>fetch_id_matching</code>, since making a network call in our test
would be both slow and unreliable. This means we need two different
implementations of <code>NetworkClient</code>: one for tests, and one for
production. Using a common trait for the two implementations, we could
write the following:</p>
<pre><pre class="playground"><code class="language-rust">trait TNetworkClient {
    fn fetch_id_matching(&amp;self, a: u32) -&gt; i32;
}

struct NetworkClient {
    /* data here */
}

impl TNetworkClient for NetworkClient {
    fn fetch_id_matching(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}

struct Service&lt;C: TNetworkClient&gt; {
    client: C,
}

impl&lt;C: TNetworkClient&gt; Service&lt;C&gt; {
    fn do_stuff(&amp;self) -&gt; i32 {
        self.client.fetch_id_matching(3)
    }
}

#[cfg(test)]
struct MockNetworkClient {
    mocked_fetch_id_matching_result: i32,
    mocked_fetch_id_matching_argument: std::cell::Cell&lt;u32&gt;,
}

#[cfg(test)]
impl TNetworkClient for MockNetworkClient {
    fn fetch_id_matching(&amp;self, a: u32) -&gt; i32 {
        self.mocked_fetch_id_matching_argument.set(a);
        self.mocked_fetch_id_matching_result
    }
}

<span class="boring">struct MockNetworkClient {
</span><span class="boring">    mocked_fetch_id_matching_result: i32,
</span><span class="boring">    mocked_fetch_id_matching_argument: std::cell::Cell&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TNetworkClient for MockNetworkClient {
</span><span class="boring">    fn fetch_id_matching(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        self.mocked_fetch_id_matching_argument.set(a);
</span><span class="boring">        self.mocked_fetch_id_matching_result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>
#[cfg(test)]
#[test]
fn service_does_the_right_thing() {
    //creates a mocked NetworkClient
    let client = MockNetworkClient {
        mocked_fetch_id_matching_argument: std::cell::Cell::default(),
        mocked_fetch_id_matching_result: 10,
    };

    // create your service using the mocked client
    // the service is the subject under test
    let subject = Service { client };
    let id = subject.do_stuff();
    assert_eq!(id, 10);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    //creates a mocked NetworkClient
</span><span class="boring">    let client = MockNetworkClient {
</span><span class="boring">        mocked_fetch_id_matching_argument: std::cell::Cell::default(),
</span><span class="boring">        mocked_fetch_id_matching_result: 10,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // create your service using the mocked client
</span><span class="boring">    // the service is the subject under test
</span><span class="boring">    let subject = Service { client };
</span><span class="boring">    let id = subject.do_stuff();
</span><span class="boring">    assert_eq!(id, 10);
</span><span class="boring">}</span></code></pre></pre>
<p>Unfortunately, we have now changed our <em>production</em> code to
accommodate our <em>tests</em>, not because this is a better design but
because of testing requirements. Tests should <em>guide</em> the design of
your code without forcing undue complexity that only benefits the
tests. Now, every user of <code>Service</code> needs to explicitly call out the
<code>TNetworkClient</code> trait, thus cluttering the function/struct signature
of anything dealing with <code>Service</code>. Furthermore, the <code>TNetworkClient</code>
trait is an unnecessary layer of abstraction for your production code,
which only uses one implementation of the trait.</p>
<p>While the code above is a simple example, imagine having to add mock
interfaces to all the structs in a mature codebase. Most mocking
frameworks for Rust are currently based on this approach. Although
most can automatically generate the mock structs from traits, you
still need to define hand-written traits for every mockable struct,
and you still have to deal with generics and traits in your
function/struct signatures.</p>
<p><code>faux</code> takes a different approach by transforming your struct and its
methods into mockable versions of themselves. These transformations
can be (and should be!) gated to only the <code>test</code> cfg, thus having zero
impact on your production code.</p>
<h2 id="closing-note"><a class="header" href="#closing-note">Closing note</a></h2>
<p><code>faux</code> is in a very early stage of development, and definitely does
not cover all the possibilities of a traitless mocking
framework. Thus, there is no guarantee of API stability between
releases, although every attempt will be made to keep the API
consistent. Please read the <a href="https://docs.rs/faux/">docs</a> for the most up to date information
on <code>faux</code> functionality.</p>
<p>See the <a href="https://github.com/nrxus/faux/issues">issues</a> in Github for an updated list of limitations and to get
an idea of what might be coming next.</p>
<p>Feedback is always welcome, so feel free to open issues or send PRs.</p>
<p>A huge thanks to <a href="https://github.com/CodeSandwich/Mocktopus">mocktopus</a>, another traitless Rust mocking
framework, which was a huge inspiration behind the creation of <code>faux</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-an-inside-look-"><a class="header" href="#-an-inside-look-">🔍 an inside look 🔍</a></h1>
<p><a href="https://github.com/nrxus/faux"><code>faux</code></a> is a traitless Rust mocking framework for creating mock
objects out of user-defined structs. For more on faux's capabilities,
take a look at the <a href="blog/./release.html">release blog post</a> or the <a href="https://docs.rs/faux/">documentation</a>.</p>
<p><code>faux</code> creates mocks of your structs to be used in unit tests, making
them fast and reliable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate faux;
</span><span class="boring">
</span>#[cfg_attr(test, faux::create)]
<span class="boring">#[faux::create]
</span>pub struct NetworkClient {
    /* data here */
}

#[cfg_attr(test, faux::methods)]
<span class="boring">#[faux::methods]
</span>impl NetworkClient {
    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}

struct Service {
    client: NetworkClient,
}

impl Service {
    fn do_stuff(&amp;self) -&gt; i32 {
        self.client.fetch(3)
    }
}

#[cfg(test)]
#[test]
fn service_does_the_right_thing() {
    let mut client = NetworkClient::faux();

    faux::when!(client.fetch).then(|i| {
        assert_eq!(i, 3, "expected service to send '3'");
        10
    });

    let subject = Service { client };
    let id = subject.do_stuff();
    assert_eq!(id, 10);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let mut client = NetworkClient::faux();
</span><span class="boring">
</span><span class="boring">   faux::when!(client.fetch).then(|i| {
</span><span class="boring">        assert_eq!(i, 3, "expected service to send '3'");
</span><span class="boring">        10
</span><span class="boring">   });
</span><span class="boring">
</span><span class="boring">   let subject = Service { client };
</span><span class="boring">   let id = subject.do_stuff();
</span><span class="boring">   assert_eq!(id, 10);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p><em><strong>DISCLAIMER:</strong> this is a simplified version of how <code>faux</code> works as
of February 2020, which may change in future versions. To see the most
up to date transformations of your code, use <code>cargo-expand</code></em></p>
<p><code>faux</code> uses attributes to transform your structs into mockable
versions of themselves at compile time.</p>
<p>The rest of the section focuses on code that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NetworkClient {
    /* data here */
}

impl NetworkClient {
    pub fn new() -&gt; Self {
        NetworkClient {
            /* data here */
        }
    }

    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>faux</code>, or any other mocking framework, needs to do two things to the
code snippet above: create a fake version of <code>NetworkClient</code>, and
provide a way to inject fake implementations of its methods.</p>
<h3 id="creating-mockable-structs"><a class="header" href="#creating-mockable-structs">Creating mockable structs</a></h3>
<p><code>faux</code> provides the attribute macro <code>#[faux::create]</code> to transform a
struct definition into a mockable version of itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate faux;
</span>#[faux::create]
pub struct NetworkClient {
    /* data here */
}
<span class="boring">}</span></code></pre></pre>
<p>From <code>faux</code>'s perspective, a mockable version of a struct:</p>
<ul>
<li>Is indistinguishable from the original struct, from a user's
perspective</li>
<li>Can instantiate the original version because we do not always want a
mocked instance</li>
<li>Can instantiate a mocked version without any additional data</li>
</ul>
<p>At a high level, <code>faux</code>'s transformation process consists of the
following steps:</p>
<ol>
<li>Check that all struct fields are private; fail to compile otherwise</li>
<li>Clones the definition of the struct</li>
<li>Rename the original definition such that it is saved elsewhere</li>
<li>Replace the cloned definition's fields with an <code>enum</code> of two
variants, the fake and the real version</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// same name so no one can tell the difference
pub struct NetworkClient(MaybeNetworkClient);

enum MaybeNetworkClient {
    // a fake does not need any data about the real network client
    Fake,
    // in case the user wants a real network client
    Real(RealNetworkClient)
}

// save the real definition somewhere else so it may still be created
struct RealNetworkClient {
    /* data here */
}

impl NetworkClient {
    // provide a method to create a fake instance of NetworkClient
    fn fake_please() -&gt; NetworkClient {
        NetworkClient(MaybeNetworkClient::Fake)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The code snippet above is a simplified version of the transformation
<code>#[faux::create]</code> performs on <code>NetworkClient</code>. The mock requirements
are satisfied:</p>
<ul>
<li>Indistinguishable from the original struct
<ul>
<li>Although the transformed struct no longer has its original fields,
callers that expect a <code>NetworkClient</code> continue to work as expected
(provided they do not try to directly access those fields)</li>
<li>External information is kept the same (i.e., visibility,
attributes)</li>
</ul>
</li>
<li>Real instances can be created
<ul>
<li>The internal enum can be either a fake or a real instance</li>
<li>The real definition is kept in a struct with a different name for
instantiation</li>
</ul>
</li>
<li>Mock instances can be created
<ul>
<li>The fake variant of the internal enum knows nothing about
<code>RealNetworkClient</code></li>
</ul>
</li>
</ul>
<h3 id="creating-mockable-methods"><a class="header" href="#creating-mockable-methods">Creating mockable methods</a></h3>
<p><code>faux</code> provides the attribute macro <code>#[faux::methods]</code> to transform
method definitions inside an <code>impl</code> block into mockable versions of
themselves.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate faux;
</span><span class="boring">#[faux::create]
</span><span class="boring">pub struct NetworkClient {}
</span>#[faux::methods]
impl NetworkClient {
    pub fn new() -&gt; Self {
        NetworkClient {
            /* data here */
        }
    }

    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        /* does some complicated stuff, maybe network calls */
<span class="boring">        5
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>From <code>faux</code>'s perspective, a mockable version of a method:</p>
<ul>
<li>Is indistinguishable from the original method, from a user's
perspective</li>
<li>Can call the real method because we do not always want a mocked method</li>
<li>Can run arbitrary code provided by the user</li>
</ul>
<p>At a high level, <code>faux</code>'s transformation process consists of the following steps:</p>
<ol>
<li>Clone the <code>impl</code> block</li>
<li>Make the original <code>impl</code> block be an <code>impl</code> of the mocked struct
instead</li>
<li>Add <code>when_*</code> methods per public method in the cloned <code>impl</code></li>
<li>Modify the cloned methods to either proxy to or call the real
instance</li>
<li>Proxy the associated functions and private methods to the original
definitions</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">   Fake,
</span><span class="boring">   Real(RealNetworkClient)
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient {}
</span>// the numbers in the comments represent sections
// that will be explained in further detail later
impl NetworkClient {
    // (1)
    pub fn new() -&gt; Self {
        Self(MaybeNetworkClient::Real(RealNetworkClient::new()))
    }

    // (2)
    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        // proxy to the real method for real instances
        // somehow get fake data when it is a mocked instance
        match self {
            Self(MaybeNetworkClient::Real(real)) =&gt; real.fetch(a),
            Self(MaybeNetworkClient::Fake) =&gt; {
                /* somehow get the fake data */
<span class="boring">                10
</span>            }
        }
    }
}

// (3)
mod real_impl_of_NetworkClient {
    // (3)
    type NetworkClient = super::RealNetworkClient;

    use super::*;

    impl NetworkClient {
        pub fn new() -&gt; Self {
            NetworkClient {
                /* data here */
            }
        }

        pub fn fetch(&amp;self, a: u32) -&gt; i32 {
            /* does some complicated stuff, maybe network calls */
<span class="boring">            5
</span>        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>The code snippet above is a simplified version of the transformation
<code>#[faux::method]</code> performs on the <code>impl</code> block. This is a bit more
complicated than making a mockable struct and involves the following
components:</p>
<ol>
<li>
<p>Returning a real instance</p>
<p>Because we are only worried about mocking instances of methods, we
can proxy to the real implementations of any associated function (a
function that does not have a receiver, e.g., <code>&amp;self</code> or <code>self: Rc&lt;Self&gt;</code>).</p>
<p>However, because the <code>new</code> function above returns an instance of
the mockable struct, while the real implementation returns an instance
of the real struct, we need to to wrap the <code>RealNetworkClient</code>
instance inside a <code>NetworkClient</code>.</p>
</li>
<li>
<p>Methods</p>
<p>Methods are fairly simple to handle. We match on the receiver, and
then proxy to the real implementation if we are a real instance or
<em>somehow</em> get the mock data if we are not. More on this <em>somehow</em>
later.</p>
</li>
<li>
<p>The real implementation</p>
<p>Similar to the mockable struct case, we want to keep our real
implementation somewhere so it can be called when needed. The hitch is
that our real implementation refers to <code>NetworkClient</code> as if it were
the real struct, e.g., when making a new instance, returning an
object, or as the name in the <code>impl</code> statement. While we could go
through the entire impl block and try to rename every mention of
<code>NetworkClient</code> with <code>RealNetworkClient</code>, a lazier approach that works
just fine is to use a type alias. However, type aliases are not yet
allowed inside <code>impl</code> blocks. To get around this limitation, we put the
alias and the real implementation in their own internal mod.</p>
</li>
</ol>
<p>We have now satisfied the first two requirements of what constitutes a
mockable method.</p>
<ul>
<li>Is indistinguishable from the original method
<ul>
<li>By keeping the same function and method signatures, external
callers cannot tell that the methods have been transformed.</li>
</ul>
</li>
<li>Real methods can be called
<ul>
<li>The real implementation is saved so it can be called for real
instances.</li>
</ul>
</li>
</ul>
<p>However, we have not satisfied the third requirement. There is no way
for the user to provide arbitrary code to be run during tests.</p>
<h3 id="injecting-mock-methods"><a class="header" href="#injecting-mock-methods">Injecting mock methods</a></h3>
<p>Ideally, we would like to have different mock instances of
the same struct, each with their own mocked methods. This means that
the mocked information belongs to the mocked instance. This changes
our definition of our mockable <code>NetworkClient</code> from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NetworkClient(MaybeNetworkClient);

enum MaybeNetworkClient {
    Fake,
    Real(RealNetworkClient),
}

pub struct RealNetworkClient { /* some data */ }
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NetworkClient(MaybeNetworkClient);

enum MaybeNetworkClient {
    Fake(MockStore),
    Real(RealNetworkClient),
}

pub struct RealNetworkClient { /* some data */ }

#[derive(Default)]
pub struct MockStore { /* store mocks somehow */ }

impl MockStore {
    pub fn get_mock(&amp;self, name: &amp;str) -&gt; Option&lt;Mock&gt; {
        /* somehow return the mock matching the name */
<span class="boring">        None
</span>    }
}

pub struct Mock { /* represent a mock somehow */ }

impl Mock {
    pub fn call&lt;I,O&gt;(self, inputs: I) -&gt; O {
        /* somehow produce an output */
<span class="boring">        panic!()
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<p>We have added a <code>MockStore</code> to the <code>Fake</code> variant of the
<code>MaybeNetworkClient</code> enum. This allows us to store and retrieve mocks
when we have a fake instance of <code>NetworkClient</code>.  We derive <code>Default</code>
for <code>MockStore</code> to denote that it can be created without any
data. This is important because we need to be able to create a mock
instance of the <code>NetworkClient</code> from nothing.</p>
<p>We can now now flesh out the mockable definition of <code>fetch</code>:</p>
<pre><pre class="playground"><code class="language-rust">impl NetworkClient {
    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
        match self {
            Self(MaybeNetworkClient::Real(real)) =&gt; real.fetch(a),
            Self(MaybeNetworkClient::Fake(mock_store)) =&gt; {
                mock_store
                    // retrieve the mock using the name of the function
                    .get_mock("fetch")
                    // check the mock was setup; panic if it was not
                    .expect("no mock found for method 'fetch'")
                    // pass in fetch's parameter to the mocked method
                    .call(a)
            }
        }
    }
}
<span class="boring">pub struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">   Fake(MockStore),
</span><span class="boring">   Real(RealNetworkClient)
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient {}
</span><span class="boring">impl Mock {
</span><span class="boring">    pub fn call&lt;I,O&gt;(self, inputs: I) -&gt; O {
</span><span class="boring">        panic!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct MockStore {}
</span><span class="boring">pub struct Mock {}
</span><span class="boring">
</span><span class="boring">impl MockStore {
</span><span class="boring">    fn get_mock(&amp;self, name: &amp;'static str) -&gt; Option&lt;Mock&gt; {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl RealNetworkClient {
</span><span class="boring">    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        5
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>We are now just missing one key piece: saving mocks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">   Fake(MockStore),
</span><span class="boring">   Real(RealNetworkClient)
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient {}
</span><span class="boring">pub struct MockStore {}
</span><span class="boring">
</span>impl NetworkClient {
    pub fn when_fetch(&amp;mut self) -&gt; When&lt;'_, u32, i32&gt; {
        match &amp;mut self.0 {
            MaybeNetworkClient::Fake(store) =&gt; When {
                store,
                method_name: "fetch",
                _marker: std::marker::PhantomData,
            },
            MaybeNetworkClient::Real(_) =&gt; panic!("cannot mock a real instance"),
        }
    }
}

// store the expected inputs and output in the type
struct When&lt;'q, I, O&gt; {
    method_name: &amp;'static str,
    store: &amp;'q mut MockStore,
    _marker: std::marker::PhantomData&lt;(*const I, *const O)&gt;,
}

impl&lt;I, O&gt; When&lt;'_, I, O&gt; {
    pub fn then(self, mock: impl FnMut(I) -&gt; O) {
        self.store.save_mock(self.method_name, mock);
    }
}

impl MockStore {
    pub fn save_mock&lt;I,O&gt;(&amp;mut self, name: &amp;'static str, f: impl FnMut(I) -&gt; O) {
        /* somehow save the mock with the given name */
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>When</code> struct above provides a method to that saves the given mock
inside the <code>MockStore</code>. We have also added a method to <code>NetworkClient</code>
that returns an instance of <code>When</code> with information about the <code>fetch</code>
method, thus allowing us to mock <code>fetch</code>.</p>
<p>We can now write code that looks like this:</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">fn main() {
</span>let mut mock = NetworkClient::fake_please();
mock.when_fetch().then(|i| i as i32);
let fetched = mock.fetch(3);
assert_eq!(fetched, 3);
<span class="boring">}
</span><span class="boring">struct NetworkClient(MaybeNetworkClient);
</span><span class="boring">enum MaybeNetworkClient {
</span><span class="boring">    Fake(MockStore),
</span><span class="boring">    Real(RealNetworkClient),
</span><span class="boring">}
</span><span class="boring">pub struct RealNetworkClient { /* some data */ }
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MockStore { /* store mocks somehow */ }
</span><span class="boring">impl MockStore {
</span><span class="boring">    pub fn get_mock(&amp;self, name: &amp;str) -&gt; Option&lt;Mock&gt; {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">    pub fn save_mock&lt;I,O&gt;(&amp;mut self, name: &amp;'static str, f: impl FnMut(I) -&gt; O) {
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">pub struct Mock {}
</span><span class="boring">impl Mock {
</span><span class="boring">    pub fn call&lt;I,O&gt;(self, inputs: I) -&gt; O {
</span><span class="boring">        panic!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl NetworkClient {
</span><span class="boring">    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Self(MaybeNetworkClient::Real(real)) =&gt; real.fetch(a),
</span><span class="boring">            Self(MaybeNetworkClient::Fake(mock_store)) =&gt; {
</span><span class="boring">                mock_store
</span><span class="boring">                    // retrieve the mock using the name of the function
</span><span class="boring">                    .get_mock("fetch")
</span><span class="boring">                    // check the mock was setup; panic if it was not
</span><span class="boring">                    .expect("no mock found for method 'fetch'")
</span><span class="boring">                    // pass in fetch's parameter to the mocked method
</span><span class="boring">                    .call(a)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn fake_please() -&gt; NetworkClient {
</span><span class="boring">         NetworkClient(MaybeNetworkClient::Fake(MockStore::default()))
</span><span class="boring">    }
</span><span class="boring">    pub fn when_fetch(&amp;mut self) -&gt; When&lt;'_, u32, i32&gt; {
</span><span class="boring">        match &amp;mut self.0 {
</span><span class="boring">            MaybeNetworkClient::Fake(store) =&gt; When {
</span><span class="boring">                store,
</span><span class="boring">                method_name: "fetch",
</span><span class="boring">                _marker: std::marker::PhantomData,
</span><span class="boring">            },
</span><span class="boring">            MaybeNetworkClient::Real(_) =&gt; panic!("cannot mock a real instance"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct When&lt;'q, I, O&gt; {
</span><span class="boring">    method_name: &amp;'static str,
</span><span class="boring">    store: &amp;'q mut MockStore,
</span><span class="boring">    _marker: std::marker::PhantomData&lt;(*const I, *const O)&gt;,
</span><span class="boring">}
</span><span class="boring">impl&lt;I, O&gt; When&lt;'_, I, O&gt; {
</span><span class="boring">    pub fn then(self, mock: impl FnMut(I) -&gt; O) {
</span><span class="boring">        self.store.save_mock(self.method_name, mock);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl RealNetworkClient {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        RealNetworkClient {}
</span><span class="boring">    }
</span><span class="boring">    pub fn fetch(&amp;self, a: u32) -&gt; i32 {
</span><span class="boring">        5
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>You may have noticed that we largely omitted the implementation of
<code>MockStore</code> and <code>Mock</code>. The implementations of these are pretty hairy,
and thus out of scope for this blog post. However, feel free to read
the source code of <a href="https://github.com/nrxus/faux"><code>faux</code></a> for more information. In reality,
<code>MockStore</code> and <code>Mock</code> requires a few more bounds on the injected mock
to both enable safe mocking and provide a version with more relaxed
bounds that is gated by <code>unsafe</code>.</p>
<h2 id="final-remarks"><a class="header" href="#final-remarks">Final remarks</a></h2>
<p>You have now seen a simplified version of the code <code>faux</code>
produces. Remember that <code>faux</code>'s expansions should be gated to only
your <code>test</code> cfg, thus having no compile or run time impact on a <code>cargo check</code> or <code>cargo build</code>. If I missed anything, or if something was not
clear, feel free to submit an issue or PR to <a href="https://github.com/nrxus/faux"><code>faux</code></a> as the blog also
lives there as a GitHub page. I will do my best to clarify or to
update the blog.</p>
<p>Feedback is always appreciated. Happy mocking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-landing-v01-"><a class="header" href="#-landing-v01-">🪂 landing v0.1 🪂</a></h1>
<p>faux is a mocking library that allows you to mock the methods of
structs for testing without complicating or polluting your code. This
post is about the road to a beta version over the past year. To get
started on faux, jump over to its
<a href="https://github.com/nrxus/faux/">repo</a> and
<a href="https://docs.rs/faux/">documentation</a>!</p>
<h2 id="towards-stability"><a class="header" href="#towards-stability">Towards stability</a></h2>
<p>The first release of faux came with this warning:</p>
<blockquote>
<p>faux is in its early alpha stages, so there are no guarantees of API
stability.</p>
</blockquote>
<p>faux has stayed in this stage for over a year, releasing only in the
<code>0.0.x</code> range. This allowed faux to experiment and make breaking
changes for the sake of of a better, more usable, API. However, part
of the usability of a library is its stability. The new <code>0.1</code> release
marks the beginning of a more stable API. Now, users can choose to
only take non-breaking changes while faux still has the flexibility to
experiment in a more controlled manner.</p>
<h2 id="the-old-faux"><a class="header" href="#the-old-faux">The old faux</a></h2>
<p>A lot has changed over the past year for faux. This post focuses on:</p>
<ul>
<li>Argument matchers</li>
<li>Mocking without closures</li>
<li>Safe interface</li>
</ul>
<p>To demonstrate, here is some test code that uses faux from a year ago:</p>
<pre><pre class="playground"><code class="language-rust">#[test]
fn bus_stops() {
    // creates a mock for bus::Client
    let mut bus_client = bus::Client::faux();

    let expected_stops = vec![bus::StopInfo {
        id: String::from("1_1234"),
        direction: String::from("N"),
        name: String::from("some bus"),
        lat: 34.3199,
        lon: 23.12005,
    }];

    // unsafe because mocks with references as inputs required them
    unsafe {
        when!(bus_client.stops).then(|q| {
            // manually assert that it was the expected input
            assert_eq!(
                *q,
                bus::StopsQuery {
                    lat: 34.32,
                    lon: 23.12,
                    lat_span: 0.002,
                    lon_span: 0.0005,
                    max_count: 20,
                }
            );
            // we are always returning the same data so a closure is overkill
            Ok(expected_stops.clone())
        })
    }

     /* snip */
<span class="boring">    let area = Area {
</span><span class="boring">        lat: 34.32,
</span><span class="boring">        lon: 23.12,
</span><span class="boring">        lat_span: 0.002,
</span><span class="boring">        lon_span: 0.0005,
</span><span class="boring">        limit: None,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let subject = Client::new(seattle_crime::Service::faux(), bus_client);
</span><span class="boring">
</span><span class="boring">    let actual_stops = subject
</span><span class="boring">        .bus_stops(&amp;area)
</span><span class="boring">        .expect("expected a succesful bus stop response");
</span><span class="boring">
</span><span class="boring">    assert_eq!(actual_stops, expected_stops);
</span>}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Compared to faux today, there are three major issues with the test above:</p>
<ol>
<li>Even the simplest of mocks requires <code>unsafe</code>.</li>
<li>Checking expected arguments is verbose.</li>
<li>No shorthand to mock the return value without a closure.</li>
</ol>
<h2 id="the-new-faux"><a class="header" href="#the-new-faux">The new faux</a></h2>
<p>Now let's look at this same test today:</p>
<pre><pre class="playground"><code class="language-rust">#[test]
fn bus_stops() {
    let mut bus_client = bus::Client::faux();

    let expected_stops = vec![bus::StopInfo {
        id: String::from("1_1234"),
        direction: String::from("N"),
        name: String::from("some bus"),
        lat: 34.3199,
        lon: 23.12005,
    }];

    // no more `unsafe` for mocking methods with references as arguments
    // when! supports argument matching
    when!(bus_client.stops(bus::StopsQuery {
        lat: 34.32,
        lon: 23.12,
        lat_span: 0.002,
        lon_span: 0.0005,
        max_count: 20,
    }))
    // for simple cases we can just mock the return value
    .then_return(Ok(expected_stops.clone()));

    /* snip */
<span class="boring">    let area = Area {
</span><span class="boring">        lat: 34.32,
</span><span class="boring">        lon: 23.12,
</span><span class="boring">        lat_span: 0.002,
</span><span class="boring">        lon_span: 0.0005,
</span><span class="boring">        limit: None,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let subject = Client::new(seattle_crime::Service::faux(), bus_client);
</span><span class="boring">
</span><span class="boring">    let actual_stops = subject
</span><span class="boring">        .bus_stops(&amp;area)
</span><span class="boring">        .expect("expected a succesful bus stop response");
</span><span class="boring">
</span><span class="boring">    assert_eq!(actual_stops, expected_stops);
</span>}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The issues mentioned in the previous section have all been addressed:</p>
<ol>
<li>Mocking methods with references as arguments is no longer unsafe.</li>
<li><code>when!</code> now supports passing argument matchers.</li>
<li><code>then_return!</code> was added to mock just the return values for simple
cases</li>
</ol>
<p>For more information about the supported argument matchers, see the
<a href="https://docs.rs/faux/0.1.0/faux/macro.when.html">docs</a>.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next</a></h2>
<h3 id="guide"><a class="header" href="#guide">Guide</a></h3>
<p>As the API surface of faux grows, it has become evident that a
<a href="blog/../faux.html">guide</a> (WIP) is necessary to cover topics not
appropriate for the API docs. I welcome
<a href="blog/(https://github.com/nrxus/faux/issues/38)">suggestions</a> on content
that should be covered by the guide.</p>
<h3 id="call-verification"><a class="header" href="#call-verification">Call Verification</a></h3>
<p>Speaking as a user of faux, my personal biggest feature request is
call verification. In general, testing outputs is preferable to
testing side effects, as the latter are more tied to implementation
details. However, there <em>are</em> certain cases where you would want to
verify a side effect, so faux should support this.</p>
<h3 id="existing-issues"><a class="header" href="#existing-issues">Existing issues</a></h3>
<p>A lot of the features that exist in faux today came from people
posting issues/PRs. Please feel free to look through the current
<a href="https://github.com/nrxus/faux/issues">issues</a> and comment on any that
would greatly help your testing experience if addressed.</p>
<h3 id="new-issues"><a class="header" href="#new-issues">New issues</a></h3>
<p>If you have any feature requests that are not covered by existing
issues, please submit a new issue.</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Over the past year, multiple contributors submitted issues and PRs to
help improve and drive the direction of faux. A huge thanks to:</p>
<ul>
<li><a href="https://github.com/muscovite">@muscovite</a></li>
<li><a href="https://github.com/TedDriggs">@TedDriggs</a></li>
<li><a href="https://github.com/Wesmania">@Wesmania</a></li>
<li><a href="https://github.com/sazzer">@sazzer</a></li>
<li><a href="https://github.com/kungfucop">@kungfucop</a></li>
<li><a href="https://github.com/audunhalland">@audunhalland</a></li>
<li><a href="https://github.com/wcampbell0x2a">@wcampbell0x2a</a></li>
<li><a href="https://github.com/pickfire">@pickfire</a></li>
</ul>
<p>for the time you spent contributing to faux!</p>
<p>Continue the conversation in</p>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/mu2gka/faux_a_struct_mocking_library_landing_v01/">reddit</a></li>
<li><a href="https://users.rust-lang.org/t/faux-a-struct-mocking-library-landing-v0-1/58619">rust forum</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
